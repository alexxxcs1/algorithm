# 算法记录 #

## Geofencing.js ##

地理围栏 右射线 算法，判断坐标是否在地理围栏内，同样的右射线算法能判断触摸点是否在某个轮廓内（用于canvas点击sprite判断）

## canvas 多层级sprite性能优化思路 ##

当存在 多个（如10个） 不同层级的sprite的时候，想要修改中间层级的sprite的属性，往往需要重新渲染 N多次 精灵

原逻辑 : 遍历10个sprite，每个都重新渲染

优化逻辑 ： 获取 需要修改的sprite（下称S） 的层级，将精灵分为 层级大于S 的和 层级小于S 的两个组，将两个组合成两个sprite实例，先渲染 层级小于S的组实例 然后渲染 修改后的S 最后渲染 层级大于S的组实例

## PropStateHOC ##

一个解决 React Native 内 大量组件需要重绘的时候性能的高阶组件~~优化~~方案 

是的，我花了一小时来写这个废物东西，实际上这个的HOC的功能不过是一个把逻辑复杂复杂复杂化的 一个写了 套了高阶组件(没有订阅功能)的自定义重绘逻辑(shouldComponentUpdate)的 组件

写这个废物东西的原因是因为 因为某个**偏执**且**技术一般**的 领导 提出的一个不合理的代码设计方案

冲突背景：新页面 & 需要在他团队自己开发的 觉得比React聪明的 轮子下开发 & 他觉得一个尝到甜头的方案能用到所有地方

#### 他的设计
>
> 由于在之前的页面中，有一个需 在更新了数据后，重绘巨量组件的 前提，他提出的设计是:
>
> 在需要进行变化的组件内 自行维护react state，当点击的时候，被点击的组件优先setState更新组件的选择状态
>
> 由于尝到了甜头，他想把所有的组件都做成 外部传入props转成state，并且维护两套 数据源 的这种设计
>
#### 我反对的原因(对事不对人)
>
> 首先我同意这个极端情况下，这个方案的确能有效的缓解用户在点击按钮时UI的响应迟缓问题
>
> 但是，这个其实是**交互的优化**，而不是**性能的优化**，且并不适用所有的情况，新页面并不会出现修改一个数据导致巨量的组件需要重绘的问题，只要shouldComponentUpdate写的好，是不会有UI反应特别迟缓的问题
>
> 且我看了一下 之前的页面 中，实际上 修改一个数据导致巨量的组件需要重绘的问题 也并不存在，我个人认为导致UI反应迟缓的问题是他自己团队的轮子造的不好导致的很多不需要重绘的地方发生了重绘
>
> 且这个方案对于 组件的开发 并不友好，外部需要维护一份数据，内部自己维护一份数据，如果嵌套的深了，更是会有多份数据的产生，为了凤毛麟角的**交互的优化**而舍弃一些应该遵循的设计理念 **(数据应有的唯一性)** 我觉得是得不偿失的。

#### 我的吐槽(对人不对事)

> **偏执**且**技术一般** 是让我十分讨厌他的原因，且由于他的**偏执**，这个新的页面也 完全采用他的方式开发，他对于他 **技术一般** 的设计理念 有着迷之自信，我想这也是 **大多数人** 看不惯他的原因
> 也是如此，自从我所在的团队由于 **某些办公室政治** 的原因，归到他的下面后，几乎除了我都转岗的转岗，离职的离职，可能真的在办公室里，大领导更看重的是能 **吹牛** 而非默默无闻的 **技术开发** (不指我，指前领导) 
